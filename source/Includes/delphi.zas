unit delphi;

interface

Uses cmd;

type 
  TDelpiOptions = record
    Platform: string;
    SearchPath: string;
    QuietCompile: boolean;
    UnitAliases: string;
    ConditionalDefines: string;
    Namespaces: string;
    UnitOutputDirectory: string;
    OutputDirectory: string;
    IncludeDirectories: string;
    UnitDirectories: string;
    OtherParameters: string;
  end;

const
   DELPHI7    = 7;
   DELPHI2005 = 9;
   DELPHI2006 = 10;
   DELPHI2007 = 11;
   DELPHI2009 = 12;
   DELPHI2010 = 14;
   DELPHIXE   = 15;
   DELPHIXE2  = 16;
   DELPHIXE3  = 17;
   DELPHIXE4  = 18;
   DELPHIXE5  = 19;
   DELPHIXE6  = 20;
   DELPHIXE7  = 21;
   DELPHIXE8  = 22;
   DELPHI10   = 23;
   DELPHI10_1 = 24;

function GetBDSRegKey(Key: string; Name: string): string;
function GetBDSRegistery(aCompilerVersion: integer; Name: string): string;
function DelphiBuild(aCompilerVersion: integer;aProject: string; aDelphiOptions:TDelpiOptions): Integer;
   
implementation

function GetBDSRegistery(aCompilerVersion: integer; Name: string): string;
var 
  lsKey: string;
begin
  Result := '';
    
  case aCompilerVersion of
    DELPHI7    : lsKey := 'Borland\Delphi\7';
    DELPHI2005 : lsKey := 'Borland\BDS\3';
    DELPHI2006 : lsKey := 'Borland\BDS\4';
    DELPHI2007 : lsKey := 'Borland\BDS\5';
    DELPHI2009 : lsKey := 'CodeGear\BDS\6';
    DELPHI2010 : lsKey := 'CodeGear\BDS\7';
    DELPHIXE   : lsKey := 'Embarcadero\BDS\8';
    DELPHIXE2  : lsKey := 'Embarcadero\BDS\9';
    DELPHIXE3  : lsKey := 'Embarcadero\BDS\10';
    DELPHIXE4  : lsKey := 'Embarcadero\BDS\11';
    DELPHIXE5  : lsKey := 'Embarcadero\BDS\12';
    DELPHIXE6..DELPHI10_1  : lsKey := 'Embarcadero\BDS\'+ IntToStr(aCompilerVersion-6);
  
  else
    RaiseException(erCustomError, 'Invalid "delphi" constant; Supported compiler versions 7..24');
  end;

  Result := GetBDSRegKey(lsKey, Name);
end;


function GetBDSRegKey(Key: string; Name: string): string;
begin
  if Registry.KeyExists(HKEY_CURRENT_USER, 'SOFTWARE\' + Key + '.0') then
    Result := Registry.ReadString( HKEY_CURRENT_USER, 'SOFTWARE\' + Key + '.0', Name)
  else  
  if Registry.KeyExists(HKEY_LOCAL_MACHINE, 'SOFTWARE\' + Key + '.0') then
    Result := Registry.ReadString( HKEY_LOCAL_MACHINE, 'SOFTWARE\' + Key + '.0', Name)
  else  
  if Registry.KeyExists(HKEY_LOCAL_MACHINE, 'SOFTWARE\Wow6432Node\' + Key + '.0') then
    Result := Registry.ReadString( HKEY_LOCAL_MACHINE, 'SOFTWARE\Wow6432Node\' + Key + '.0', Name);
end;

function DelphiBuild(aCompilerVersion: integer;aProject: string; aDelphiOptions:TDelpiOptions): Integer;
var
  lsrootdir: string;
  lscommand: string;
  SB: TStringBuilder;
begin
  result := -1;
  
  lsrootdir := GetBDSRegistery(aCompilerVersion, 'rootdir');

  if lsrootdir = '' then 
    RaiseException(erCustomError, 'Cannot find Delphi registry key for '+ IntToStr(aCompilerVersion));

  if (aCompilerVersion in [DELPHI7, DELPHI2005, DELPHI2006]) and (lowercase(aDelphiOptions.platform) = 'msbuild') then 
    RaiseException(erCustomError, 'Compiler Version 7,9,10 does not support platform = msbuild')
  else
  if (CompareText(lowercase(aDelphiOptions.platform), 'ios32') = 0) or
     (CompareText(lowercase(aDelphiOptions.platform), 'iossimulator') = 0) then
    lsRootDir := Path.Combine(Path.Combine(lsRootDir, 'Bin'), 'dccios32.exe')
  else
  if (CompareText(lowercase(aDelphiOptions.platform), 'ios32') = 0) or
     (CompareText(lowercase(aDelphiOptions.platform), 'iossimulator') = 0) then
    lsRootDir := Path.Combine(Path.Combine(lsRootDir, 'Bin'), 'dccios32.exe')
  else
  if (CompareText(lowercase(aDelphiOptions.platform), 'android') = 0) then
    lsRootDir := Path.Combine(Path.Combine(lsRootDir, 'Bin'), 'dccaarm.EXE')
  else
  if (CompareText(lowercase(aDelphiOptions.platform), 'macosx') = 0) or
     (CompareText(lowercase(aDelphiOptions.platform), 'osx') = 0) or
     (CompareText(lowercase(aDelphiOptions.platform), 'osx32') = 0) then 
     lsRootDir := Path.Combine(Path.Combine(lsRootDir, 'Bin'), 'dccosx.exe')
  else
  if (CompareText(lowercase(aDelphiOptions.platform), '64') = 0) or
     (CompareText(lowercase(aDelphiOptions.platform), 'x64') = 0) or
     (CompareText(lowercase(aDelphiOptions.platform), 'win64') = 0) then    
     lsRootDir := Path.Combine(Path.Combine(lsRootDir, 'Bin'), 'dcc64.exe')
  else   
   if (CompareText(lowercase(aDelphiOptions.platform), '32') = 0) or
     (CompareText(lowercase(aDelphiOptions.platform), 'x86') = 0) or
     (CompareText(lowercase(aDelphiOptions.platform), 'win32') = 0) then 
    lsRootDir := Path.Combine(Path.Combine(lsRootDir, 'Bin'), 'dcc32.exe')
  else 
    RaiseException(erCustomError, 'Unsupported platform ("win32", "win64", "osx32", "iossimulator","iosdevice")');

  if not File.Exists(lsRootDir) then RaiseException(erCustomError, 'Delphi dcc not found: '+lsRootDir+' '+aDelphiOptions.platform);
    
  Try
    SB:= TStringBuilder.Create;

    SB.Append('""' + lsrootdir  + '""');

    if aDelphiOptions.QuietCompile then 
      SB.Append(' -Q');

    SB.Append(' -B '+ aProject);


    if Trim(aDelphiOptions.SearchPath) = '' then
      aDelphiOptions.SearchPath := Path.GetDirectoryName(aProject)
    else
      aDelphiOptions.SearchPath := aDelphiOptions.SearchPath +';'+Path.GetDirectoryName(aProject);

    if Trim(aDelphiOptions.UnitAliases) <> '' then
       sb.AppendFormat(' -A"%s"', [aDelphiOptions.UnitAliases]);

    if Trim(aDelphiOptions.ConditionalDefines) <> '' then
        sb.AppendFormat(' -D"%s"', [aDelphiOptions.ConditionalDefines]);
   
    if Trim(aDelphiOptions.namespaces) <> '' then
        sb.AppendFormat(' -NS"%s"', [aDelphiOptions.namespaces]);

    if Trim(aDelphiOptions.UnitOutputDirectory) <> '' then
      begin
        if aCompilerVersion > DELPHI7 then
          sb.AppendFormat(' -NO"%s" -N0"%s"', [aDelphiOptions.UnitOutputDirectory, aDelphiOptions.UnitOutputDirectory])
        else
         sb.AppendFormat(' -N"%s"', [aDelphiOptions.UnitOutputDirectory]);
      end;      

    if Trim(aDelphiOptions.OutputDirectory) <> '' then
       sb.AppendFormat(' -LE"%s" -LN"%s" -E"%s"',[aDelphiOptions.OutputDirectory, aDelphiOptions.OutputDirectory, aDelphiOptions.OutputDirectory]); 
     
    if Trim(aDelphiOptions.IncludeDirectories)  <> '' then
      sb.AppendFormat(' -I"%s"', [aDelphiOptions.IncludeDirectories])
    else
      sb.AppendFormat(' -I"%s"', [aDelphiOptions.SearchPath]);

    if Trim(aDelphiOptions.UnitDirectories)  <> '' then
      sb.AppendFormat(' -U"%s"', [aDelphiOptions.UnitDirectories])
    else
      sb.AppendFormat(' -U"%s"', [aDelphiOptions.SearchPath]);

    if Trim(aDelphiOptions.otherParameters) <> '' then
      sb.Append(' '+aDelphiOptions.otherParameters);

   
    Output.logformat('Running: %s', [SB.ToString]);

    result := ExecCMD(sb.ToString);
   
  finally
    SB.Free;
  End;

  




      (*
  

(*




 

  if not String.IsNullOrEmpty(aOptions.destinationFolder) then
    sb.AppendFormat(' -LE"{0}" -LN"{0}" -E"{0}"', aServices.ResolveWithBase(ec,aOptions.destinationFolder,True));

  if not String.IsNullOrEmpty(aOptions.includeSearchPath) then
    sb.AppendFormat(' -I"{0}"', RebuildMultiPath(aServices,ec,lDelphi,aOptions.includeSearchPath,aOptions:platform));

  if not String.IsNullOrEmpty(aOptions.unitSearchPath) then
    sb.AppendFormat(' -U"{0}"', RebuildMultiPath(aServices,ec,lDelphi,aOptions.unitSearchPath,aOptions:platform));

  if not String.IsNullOrEmpty(aOptions.otherParameters) then
    sb.Append(' '+aOptions.otherParameters);

  if not String.IsNullOrEmpty(aOptions.updateIcon) or (aOptions.updateVersionInfo <> nil) then begin
    var lRes := Path.ChangeExtension(aProject, '.res');
    UpdateResource(lRes, aServices.ResolveWithBase(ec, aOptions.updateIcon, true), aOptions.updateVersionInfo, ec);
  end;


  var lTmp := new DelayedLogger();
  var lOutput := new StringBuilder;
  aServices.Logger.LogMessage('Running: {0} {1}', lRootPath, sb.ToString);
    *)



  output.log(lscommand);
  
  //result := ExecCMD(lscommand);
 
end;
    

end.
